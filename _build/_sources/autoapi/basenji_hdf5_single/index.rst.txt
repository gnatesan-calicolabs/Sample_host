:py:mod:`basenji_hdf5_single`
=============================

.. py:module:: basenji_hdf5_single


Module Contents
---------------


Functions
~~~~~~~~~

.. autoapisummary::

   basenji_hdf5_single.main
   basenji_hdf5_single.annotate_na
   basenji_hdf5_single.batch_end
   basenji_hdf5_single.bigwig_batch
   basenji_hdf5_single.limit_segments
   basenji_hdf5_single.filter_boring
   basenji_hdf5_single.fourier_transform
   basenji_hdf5_single.latent_transform
   basenji_hdf5_single.segments_1hot
   basenji_hdf5_single.w5_batch



.. py:function:: main()


.. py:function:: annotate_na(seqs_segments, unmap_bed, seq_length, pool_width)

   Intersect the sequence segments with unmappable regions
        and annoate the segments as NaN to possible be ignored.

   Args:
     seqs_segments: list of (chrom,start,end) sequence segments
     unmap_bed: unmappable regions BED file
     seq_length: sequence length
     pool_width: pooled bin width

   Returns:
     seqs_na: NxL binary NA indicators


.. py:function:: batch_end(segments, bstart, batch_max)

   Determine the batch end that will keep the
   batch length under the given max. 


.. py:function:: bigwig_batch(wig_file, segments, seq_length, pool_width=1, stride=None, log10to2=False, cov_multiplier=1)

   Read a batch of segment values from a bigwig file

   Args:
     wig_file: Bigwig filename
     segments: list of (chrom,start,end) genomic segments to read,
                 assuming those segments are appropriate length
     seq_length: sequence length to break them into
     pool_width: average pool adjacent nucleotides of this width
     stride: advance the sequences by this amount.

   Returns:
     targets: target Bigwig value matrix


.. py:function:: limit_segments(segments, filter_bed)

   Limit to segments overlapping the given BED.

   Args
    segments: list of (chrom,start,end) genomic segments
    filter_bed: BED file to filter by

   Returns:
    fsegments: list of (chrom,start,end) genomic segments


.. py:function:: filter_boring(targets, var_t=0.01)

   Filter boring segments without signal variance.

   Args
    targets: SxLxT array of target values
    var_t: Average variance threshold

   Returns:
    targets_exciting: SxLxT array of target values


.. py:function:: fourier_transform(targets, dim)

   Fourier transform.

   Args
    targets: SxLxT array of target values
    dim: # of fourier dimensions

   Returns:
    fourier_real: transformed targets, real component
    fourier_imag: transformed targets, imaginary component


.. py:function:: latent_transform(sess, model, job, targets_wig)

   Transform raw data to latent representation.

   Args
    sess: TensorFlow session
    model: TF or sklearn model
    job: dictionary of model hyper-parameters
    targets_wig: SxLxT array of target values

   Returns:
    targets_latent: SxDxT array of target values


.. py:function:: segments_1hot(fasta_file, segments, seq_length, stride)

   Read and 1-hot code sequences in their segment batches.

   Args
    fasta_file: FASTA genome
    segments: list of (chrom,start,end) genomic segments to read
    seq_length: sequence length to break them into

   Returns:
    seqs_1hot: You know.
    seqs_segments: list of (chrom,start,end) sequence segments


.. py:function:: w5_batch(w5_file, segments, seq_length, pool_width=1, stride=None, log10to2=False, cov_multiplier=1)

   Read a batch of segment values from a bigwig file

   Args:
     w5_file: wiggle HDF5 filename
     segments: list of (chrom,start,end) genomic segments to read,
                 assuming those segments are appropriate length
     seq_length: sequence length to break them into
     pool_width: average pool adjacent nucleotides of this width
     stride: advance the sequences by this amount.

   Returns:
     targets: target Bigwig value matrix


